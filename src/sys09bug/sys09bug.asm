* NAM SYS09BUG12 SYSTEM09 MONITOR
 OPT l
 PAGE
*
* MONITOR PROGRAM FOR THE SOUTHWEST TECHNICAL
* PRODUCTS MP-09 CPU BOARD AS COMMENTED BY....
*
* ALLEN CLARK            WALLACE WATSON
* 2502 REGAL OAKS LANE   4815 EAST 97th AVE.
* LUTZ, FLA. 33549       TEMPLE TERRACE, FLA. 33617
* PH. 813-977-0347       PH. 813-985-1359
*
* MODIFIED TO SBUG09 VER 1.8 BY:  RANDY JARRETT
*                                 2561 NANTUCKET DR APT. E
*                                 ATLANTA, GA  30345
*                                 PH. 404-320-1043
*
* MODIFIED TO SYS09BUG
* FOR:     SYSTEM09 FPGA SYSTEM
* BY:      JOHN KENT
* 
* MODIFIED FOR MDSYNTH
* BY: DANIEL CLICHE
*
*       *** COMMANDS ***
*
* CONTROL A   = ALTER THE "A" ACCUMULATOR
* CONTROL B   = ALTER THE "B" ACCUMULATOR
* CONTROL C   = ALTER THE CONDITION CODE REGISTER
* CONTROL D   = ALTER THE DIRECT PAGE REGISTER
* CONTROL P   = ALTER THE PROGRAM COUNTER
* CONTROL U   = ALTER USER STACK POINTER
* CONTROL X   = ALTER "X" INDEX REGISTER
* CONTROL Y   = ALTER "Y" INDEX REGISTER
* B hhhh      = SET BREAKPOINT AT LOCATION $hhhh
* D           = 5.25" MINIFLOPPY BOOT
* E ssss-eeee = EXAMINE MEMORY
*               FROM STARTING ADDRESS ssss
*               TO ENDING ADDRESS eeee.
* G           = CONTINUE EXECUTION FROM BREAKPOINT OR SWI
* L           = LOAD TAPE
* M hhhh      = EXAMINE AND CHANGE MEMORY LOCATION hhhh
* P ssss-eeee = PUNCH TAPE, START ssss TO END eeee ADDR.
* R           = DISPLAY REGISTER CONTENTS
* S           = DISPLAY STACK FROM ssss TO $DFC0
* U           = 8" DMAF2 FLOPPY BOOT
* U           = USER EXTENSION COMMANDS AT $F000
* X           = REMOVE ALL BREAKPOINTS
*
*
***************************************************
*   SYS09BUG VARIABLE SPACE
***************************************************
*
        ORG   MONRAM
STACK   EQU   *         ; TOP OF INTERNAL STACK
NMI     RMB   2         ; USER NMI VECTOR
SWI3    RMB   2         ; SOFTWARE INTERRUPT VECTOR #3
SWI2    RMB   2         ; SOFTWARE INTERRUPT VECTOR #2
FIRQ    RMB   2         ; FAST INTERRUPT VECTOR
IRQ     RMB   2         ; INTERRUPT VECTOR
SWI     RMB   2         ; SOFTWARE INTERRUPT VECTOR
SVCVO   RMB   2         ; SUPERVISOR CALL VECTOR ORGIN
SVCVL   RMB   2         ; SUPERVISOR CALL VECTOR LIMIT
CPORT   RMB   2         ; RE-VECTORABLE CONTROL PORT
ECHO    RMB   1         ; ECHO FLAG
BPTBL   RMB  24         ; BREAKPOINT TABLE BASE ADDR
NMISAV  RMB   2         ; NMI Jump Vector Backup
TRACNT  RMB   2         ; Trace Count
*
**************************************************
*   VDU8 DISPLAY DRIVER VARIABLES                                    *
**************************************************
*
**** ALWAYS KEEP COLADX AND ROWADX TOGETHER ******
COLADX  RMB   1         ; CURSOR COLUMN
ROWADX  RMB   1         ; CURSOR ROW
**************************************************
*
NEWROW  RMB   1         ; NEW ROW TEMP FOR ESCAPE
ESCFLG  RMB   1         ; ESCAPE SEQUENCE ACTIVE
*
*
***************************************************
*   START OF ROM                                  *
***************************************************
*
        ORG   MONROM
        FDB   MONITOR
        FDB   NEXTCMD
        FDB   INCH
        FDB   INCHE
        FDB   INCHEK
        FDB   OUTCH
        FDB   PDATA
        FDB   PCRLF
        FDB   PSTRNG
        FDB   LRA
*
*
* MONITOR
*
* VECTOR ADDRESS STRING IS.....
* $F8A1-$F8A1-$F8A1-$F8A1-$F8A1-$FAB0-$FFFF-$FFFF
*
MONITOR LDX   #RAMVEC  ; POINT TO VECTOR ADDR. STRING
        LDY   #STACK   ; POINT TO RAM VECTOR LOCATION
        LDB   #$10     ; BYTES TO MOVE = 16
LOOPA   LDA   ,X+      ; GET VECTOR BYTE
        STA   ,Y+      ; PUT VECTORS IN RAM / $DFC0-$DFCF
        DECB           ; SUBTRACT 1 FROM NUMBER OF BYTES TO MOVE
        BNE   LOOPA    ; CONTINUE UNTIL ALL VECTORS MOVED
*
* CONTENTS     FROM         TO      FUNCTION
*  $F8A1       $FE40      $DFC0     USER-V
*  $F8A1       $FE42      $DFC2     SWI3-V
*  $F8A1       $FE44      $DFC4     SWI2-V
*  $F8A1       $FE46      $DFC6     FIRQ-V
*  $F8A1       $FE48      $DFC8     IRQ-V
*  $FAB0       $FE4A      $DFCA     SWI-V
*  $FFFF       $FE4C      $DFCC     SVC-VO
*  $FFFF       $FE4E      $DFCE     SVC-VL
*
        LDX   #ACIAS
        STX   CPORT    ; STORE ADDR. IN RAM
        LBSR  XBKPNT   ; CLEAR OUTSTANDING BREAKPOINTS
        LDB   #12      ; CLEAR 12 BYTES ON STACK
CLRSTK  CLR   ,-S
        DECB
        BNE   CLRSTK
        LEAX  MONITOR,PCR  ; SET PC TO SBUG-E ENTRY
        STX   10,S    ; ON STACK
        LDA   #$D0    ; PRESET CONDITION CODES ON STACK
        STA   ,S
        TFR   S,U
        LBSR  IOINIZ  ; INITIALIZE CONTROL PORT
        LDX   #MSG1   ; POINT TO MONITOR MESSAGE
        LBSR  PDATA   ; PRINT MSG
*
        LBSR  TRAINZ
*
***** NEXTCMD *****
*
NEXTCMD LDX  #MSG3   ; POINT TO MSG ">"
        LBSR PSTRNG  ; PRINT MSG
        LBSR INCH    ; GET ONE CHAR. FROM TERMINAL
        ANDA #$7F    ; STRIP PARITY FROM CHAR.
        CMPA #$0D    ; IS IT CARRIAGE RETURN ?
        BEQ  NEXTCMD ; IF CR THEN GET ANOTHER CHAR.
        TFR  A,B     ; PUT CHAR. IN "B" ACCUM.
        CMPA #$20    ; IS IT CONTROL OR DATA CHAR ?
        BGE  PRTCMD  ; IF CMD CHAR IS DATA, PRNT IT
        LDA  #'^     ; ELSE CNTRL CHAR CMD SO...
        LBSR OUTCH   ; PRINT "^"
        TFR  B,A     ; RECALL CNTRL CMD CHAR
        ADDA #$40    ; CONVERT IT TO ASCII LETTER
PRTCMD  LBSR OUTCH   ; PRNT CMD CHAR
        LBSR OUT1S   ; PRNT SPACE
        CMPB #$60
        BLE  NXTCH0
        SUBB #$20
*
***** DO TABLE LOOKUP *****
*   FOR COMMAND FUNCTIONS
*
NXTCH0  LDX  #JMPTAB ; POINT TO JUMP TABLE
NXTCHR  CMPB ,X+     ; DOES COMMAND MATCH TABLE ENTRY ?
        BEQ  JMPCMD  ; BRANCH IF MATCH FOUND
        LEAX 2,X     ; POINT TO NEXT ENTRY IN TABLE
        CMPX #TABEND ; REACHED END OF TABLE YET ?
        BNE  NXTCHR  ; IF NOT END, CHECK NEXT ENTRY
        LDX  #MSG4   ; POINT TO MSG "WHAT?"
        LBSR PDATA   ; PRINT MSG
        BRA  NEXTCMD ; IF NO MATCH, PRMPT FOR NEW CMD
JMPCMD  JSR  [,X]    ; JUMP TO COMMAND ROUTINE
        BRA  NEXTCMD ; PROMPT FOR NEW COMMAND
*
* "G" GO OR CONTINUE
*
GO      TFR  U,S
RTI     RTI
*
***** "M" MEMORY EXAMINE AND CHANGE *****
*
MEMCHG  LBSR IN1ADR  ; INPUT ADDRESS
        BVS  CHRTN   ; IF NOT HEX, RETURN
        TFR  X,Y     ; SAVE ADDR IN "Y"
MEMC2   LDX  #MSG5   ; POINT TO MSG " - "
        LBSR PSTRNG  ; PRINT MSG
        TFR  Y,X     ; FETCH ADDRESS
        LBSR OUT4H   ; PRINT ADDR IN HEX
        LBSR OUT1S   ; OUTPUT SPACE
        LDA  ,Y      ; GET CONTENTS OF CURRENT ADDR.
        LBSR OUT2H   ; OUTPUT CONTENTS IN ASCII
        LBSR OUT1S   ; OUTPUT SPACE
        LBSR BYTE    ; LOOP WAITING FOR OPERATOR INPUT
        BVC  CHANGE  ; IF VALID HEX GO CHANGE MEM. LOC.
        CMPA #8      ; IS IT A BACKSPACE (CNTRL H)?
        BEQ  MEMC2   ; PROMPT OPERATOR AGAIN
        CMPA #$18    ; IS IT A CANCEL (CNTRL X)?
        BEQ  MEMC2   ; PROMPT OPERATOR AGAIN
        CMPA #'^     ; IS IT AN UP ARROW?
        BEQ  BACK    ; DISPLAY PREVIOUS BYTE
        CMPA #$D     ; IS IT A CR?
        BNE  FORWRD  ; DISPLAY NEXT BYTE
CHRTN   RTS          ; EXIT ROUTINE
*
*
CHANGE  STA  ,Y      ; CHANGE BYTE IN MEMORY
        CMPA ,Y      ; DID MEMORY BYTE CHANGE?
        BEQ  FORWRD  ; $F972
        LBSR OUT1S   ; OUTPUT SPACE
        LDA  #'?     ; LOAD QUESTION MARK
        LBSR OUTCH   ; PRINT IT
FORWRD  LEAY 1,Y     ; POINT TO NEXT HIGHER MEM LOCATION
        BRA  MEMC2   ; PRINT LOCATION & CONTENTS
BACK    LEAY -1,Y    ; POINT TO LAST MEM LOCATION
        BRA  MEMC2   ; PRINT LOCATION & CONTENTS
*
* "S" DISPLAY STACK
* HEX-ASCII DISPLAY OF CURRENT STACK CONTENTS FROM
** CURRENT STACK POINTER TO INTERNAL STACK LIMIT.
*
DISSTK  LBSR PRTSP   ; PRINT CURRENT STACK POINTER
        TFR  U,Y
        LDX  #STACK  ; LOAD INTERNAL STACK AS UPPER LIMIT
        LEAX -1,X    ; POINT TO CURRENT STACK
        BRA  MDUMP1  ; ENTER MEMORY DUMP OF STACK CONTENTS
*
* "E" DUMP MEMORY FOR EXAMINE IN HEX AND ASCII
* AFTER CALLING 'IN2ADR' LOWER ADDRESS IN Y-REG.
*                        UPPER ADDRESS IN X-REG.
* IF HEX ADDRESSES ARE INVALID (V)=1.
*
MEMDUMP LBSR IN2ADR  ; INPUT ADDRESS BOUNDRIES
        BVS  EDPRTN  ; NEW COMMAND IF ILLEGAL HEX
MDUMP1  PSHS Y       ; COMPARE LOWER TO UPPER BOUNDS
        CMPX ,S++    ; LOWER BOUNDS > UPPER BOUNDS?
        BCC  AJDUMP  ; IF NOT, DUMP HEX AND ASCII
EDPRTN  RTS          ;
*
* ADJUST LOWER AND UPPER ADDRESS LIMITS
* TO EVEN 16 BYTE BOUNDRIES.
*
* IF LOWER ADDR = $4532
* LOWER BOUNDS WILL BE ADJUSTED TO = $4530.
*
* IF UPPER ADDR = $4567
* UPPER BOUNDS WILL BE ADJUSTED TO = $4570.
*
* ENTER WITH LOWER ADDRESS IN X-REG.
*           -UPPER ADDRESS ON TOP OF STACK.
*
AJDUMP  TFR  X,D     ; GET UPPER ADDR IN D-REG
        ADDD #$10    ; ADD 16 TO UPPER ADDRESS
        ANDB #$F0    ; MASK TO EVEN 16 BYTE BOUNDRY
        PSHS A,B     ; SAVE ON STACK AS UPPER DUMP LIMIT
        TFR  Y,D     ; $F9A5 GET LOWER ADDRESS IN D-REG
        ANDB #$F0    ; MASK TO EVEN 16 BYTE BOUNDRY
        TFR  D,X     ; PUT IN X-REG AS LOWER DUMP LIMIT
NXTLIN  CMPX ,S      ; COMPARE LOWER TO UPPER LIMIT
        BEQ  SKPDMP  ; IF EQUAL SKIP HEX-ASCII DUMP
        LBSR INCHEK  ; CHECK FOR INPUT FROM KEYBOARD
        BEQ  EDUMP
SKPDMP  LEAS 2,S     ; READJUST STACK IF NOT DUMPING
        RTS          ;
*
* PRINT 16 HEX BYTES FOLLOWED BY 16 ASCII CHARACTERS
* FOR EACH LINE THROUGHOUT ADDRESS LIMITS.
*
EDUMP   PSHS X       ; PUSH LOWER ADDR LIMIT ON STACK
        LDX  #MSG5   ; POINT TO MSG " - "
        LBSR PSTRNG  ; PRINT MSG
        LDX  ,S      ; LOAD LOWER ADDR FROM TOP OF STACK
        LBSR OUT4H   ; PRINT THE ADDRESS
        LBSR OUT2S   ; 2 SPACES
        LDB  #$10    ; LOAD COUNT OF 16 BYTES TO DUMP
ELOOP   LDA  ,X+     ; GET FROM MEMORY HEX BYTE TO PRINT
        LBSR OUT2H   ; OUTPUT HEX BYTE AS ASCII
        LBSR OUT1S   ; OUTPUT SPACE
        DECB         ; $F9D1 DECREMENT BYTE COUNT
        BNE  ELOOP   ; CONTINUE TIL 16 HEX BYTES PRINTED
*
* PRINT 16 ASCII CHARACTERS
* IF NOT PRINTABLE OR NOT VALID
* ASCII PRINT A PERIOD (.)
        LBSR OUT2S   ; 2 SPACES
        LDX  ,S++    ; GET LOW LIMIT FRM STACK - ADJ STACK
        LDB  #$10    ; SET ASCII CHAR TO PRINT = 16
EDPASC  LDA  ,X+     ; GET CHARACTER FROM MEMORY
        CMPA #$20    ; IF LESS THAN $20, NON-PRINTABLE?
        BCS  PERIOD  ; IF SO, PRINT PERIOD INSTEAD
        CMPA #$7E    ; IS IT VALID ASCII?
        BLS  PRASC   ; IF SO PRINT IT
PERIOD  LDA  #'.     ; LOAD A PERIOD (.)
PRASC   LBSR OUTCH   ; PRINT ASCII CHARACTER
        DECB         ; DECREMENT COUNT
        BNE  EDPASC
        BRA  NXTLIN
*
***** "B" SET BREAKPOINT *****
*
BRKPNT  LBSR IN1ADR  ; GET BREAKPOINT ADDRESS
        BVS  EXITBP  ; EXIT IF INVALID HEX ADDR.
        CMPX #STACK  ; ADDRESS ILLEGAL IF >=$DFC0
        BCC  BPERR   ; IF ERROR PRINT (?), EXIT
        PSHS X       ; $FA82 PUSH BP ADDRESS ON STACK
        LDX  #$FFFF  ; LOAD DUMMY ADDR TO TEST BP TABLE
        BSR BPTEST   ; TEST BP TABLE FOR FREE SPACE
        PULS X       ; POP BP ADDRESS FROM STACK
        BEQ  BPERR   ; (Z) SET, OUT OF BP TABLE SPACE
        LDA  ,X      ; GET DATA AT BREAKPOINT ADDRESS
        CMPA #$3F    ; IS IT A SWI?
        BEQ  BPERR   ; IF SWI ALREADY, INDICATE ERROR
        STA  ,Y+     ; SAVE DATA BYTE IN BP TABLE
        STX  ,Y      ; SAVE BP ADDRESS IN BP TABLE
        LDA  #$3F    ; LOAD A SWI ($3F)
        STA  ,X      ; SAVE SWI AT BREAKPOINT ADDRESS
EXITBP  RTS ;
*
*  INDICATE ERROR SETTING BREAKPOINT
*
BPERR   LBSR OUT1S   ; OUTPUT SPACE
        LDA  #'?     ; LOAD (?), INDICATE BREAKPOINT ERROR
        LBRA OUTCH   ; PRINT "?"
*
*** "X" CLEAR OUTSTANDING BREAKPOINTS ***
*
XBKPNT  LDY  #BPTBL  ; POINT TO BREAKPOINT TABLE
        LDB  #8      ; LOAD BREAKPOINT COUNTER
XBPLP   BSR  RPLSWI  ; REMOVE USED ENTRY IN BP TABLE
        DECB  $FAAC  ; DECREMENT BP COUNTER
        BNE  XBPLP   ; END OF BREAKPOINT TABLE?
        RTS
*
***** SWI ENTRY POINT *****
*
SWIE    TFR  S,U     ; TRANSFER STACK TO USER POINTER
        LDX  10,U    ; LOAD PC FROM STACK INTO X-REG
        LEAX -1,X    ; ADJUST ADDR DOWN 1 BYTE.
        BSR  BPTEST  ; FIND BREAKPOINT IN BP TABLE
        BEQ  REGPR   ; IF FOUND, REPLACE DATA AT BP ADDR
        STX  10,U    ; SAVE BREAKPOINT ADDR IN STACK
        BSR  RPLSWI  ; GO REPLACE SWI WITH ORIGINAL DATA
REGPR   LBSR REGSTR  ; GO PRINT REGISTERS
*
        LDX #0
        STX TRACNT
*
        LBRA NEXTCMD ; GET NEXT COMMAND
*
RPLSWI  LDX  1,Y     ; LOAD BP ADDRESS FROM BP TABLE
        CMPX #STACK  ; COMPARE TO TOP AVAILABLE USER MEMORY
        BCC  FFSTBL  ; GO RESET TABLE ENTRY TO $FF'S
        LDA  ,X      ; GET DATA FROM BP ADDRESS
        CMPA #$3F    ; IS IT SWI?
        BNE  FFSTBL  ; IF NOT, RESET TABLE ENTRY TO $FF'S
        LDA  ,Y      ; GET ORIGINAL DATA FROM BP TABLE
        STA  ,X      ; $FAD3 RESTORE DATA AT BP ADDRESS
FFSTBL  LDA  #$FF    ; LOAD $FF IN A-ACC
        STA  ,Y+     ; RESET BREAKPOINT TABLE DATA TO $FF'S
        STA  ,Y+     ; RESET BREAKPOINT TABLE ADDR TO $FF'S
        STA  ,Y+
        RTS
*
** SEARCH BREAKPOINT TABLE FOR MATCH **
*
BPTEST  LDY  #BPTBL  ; POINT TO BREAKPOINT TABLE
        LDB  #8      ; LOAD BREAKPOINT COUNTER
FNDBP   LDA  ,Y+     ; LOAD DATA BYTE
        CMPX ,Y++    ; COMPARE ADDRESS, IS IT SAME?
        BEQ  BPADJ   ; IF SO, ADJUST POINTER FOR TABLE ENTRY
        DECB         ; IF NOT, DECREMENT BREAKPOINT COUNTER
        BNE  FNDBP   ; AND LOOK FOR NEXT POSSIBLE MATCH
        RTS          ;
*
*
BPADJ   LEAY -3,Y    ; MOVE POINTER TO BEGIN OF BP ENTRY
        RTS
*
*
** TRACE from address AAAA BB bytes
*
TRACE   LBSR ALTPC1  ; SET UP NEW PC
        BVS  TREXIT  ; ADDRESS ERROR, EXIT
        LBSR OUT1S
        LBSR IN1ADR  ; Fetch Byte Count
        BVS TREXIT   ; Byte Count error, EXIT
        STX TRACNT
*
        LDX NMI      ; Save NMI Vector
        STX NMISAV
        LDX #NMIE    ; Set up NMI for Tracing
        STX NMI
        LBSR TRAINZ  ; Initialise Hardware
        BRA TRACEG   ; Start Trace
TREXIT  RTS
*
* CRA0 = 0 CA1 IRQ DISAB, CRA0 = 1 CA1 IRQ ENAB
* CRA1 = 1 CA1 Rising edge IRQ
* CRA2 = 0 TADATA = Data Direction, CRA2 = 1 TADATA = I/O Register
* CRA3 = 0 CA2 = 0 output, CRA3 = 1 CA2 = 1
* CRA4 = 1 ] CA2 = Set/Reset output
* CRA5 = 1 ]
* CRA6 = X CA2 Input Interrupt Flag
* CRA7 = X CA1 Interrupt Flag
*
* CRB0 = 0 CB1 IRQ DISAB, CRB0 = 1 CA1 IRQ ENAB
* CRB1 = 1 CB1 Rising edge IRQ
* CRB2 = 0 TBDATA = Data Direction, CRB2 = 1 TBDATA = I/O Register
* CRB3 = 0 CB2 = 0 output, CRB3 = 1 CB2 = 1
* CRB4 = 1 ] CB2 = Set/Reset output
* CRB5 = 1 ]
* CRB6 = X CB2 Input Interrupt Flag
* CRB7 = X CB1 Interrupt Flag
*
*
** TRACE NMI ENTRY POINT
*
NMIE    TFR  S,U
        LDA  #$36    ; Disable Interrupt, CA2 Low
        STA  TACTRL
        LDA  TADATA  ; Clear Interrupt flag by reading data port
*
        LBSR REGSTR  ; DUMP REGISTERS
*
        LDX  10,U    ; TEST IF NEXT INSTRUCTION IS A SWI
        LDA  ,X
        CMPA #$3F
        BEQ  TRACEX  ; EXIT ON SWI
*
        LDX  TRACNT  ; CHECK IF TRACE COUNT EXPIRED
        BEQ  TRACEX  ; YES, GO BACK TO THE MONITOR
        LEAX -1,X    ; ECREMENT TRACE COUNT
        STX  TRACNT
*
**  TRACE GO (RESUME SINGLE STEP)
*
TRACEG  TFR  U,S     ; SET UP PROGRAM STACK POINTER
        LDA  #TRADEL ; SET UP TIMER DELAY (NUMB CYCLES FOR RTI+1)
        STA  TADATA
        LDA  #$36    ; LOAD STROBE LOW
        STA  TACTRL
        LDA  TADATA  ; CLEAR INTERRUPT
        LDA  #$36    ; RELEASE RESET
        STA  TBCTRL
        LDA  #$3F    ; RELEASE LOAD, ENABLE CA1 NMI, CA1 RISING EDGE
        STA  TACTRL
        RTI          ; GO EXECUTE INSTRUCTION
*
TRACEX  LDX NMISAV   ; Restore NMI vector
        STX NMI
        LBRA NEXTCMD ; Jump back to the command loop.
*
** TRACE HARDWARE INITIALISATION
*
TRAINZ  LDA #$32     ; SELECT DDRA, CA2 LOW, NMI DISABLED
        STA TACTRL
        LDA #$3A     ; SELECT DDRB, CB2 HIGH, FIRQ DISABLED
        STA TBCTRL
        LDA #$FF     ; PORTA = OUTPUT
        STA TADATA
        LDA #$00     ; PORTB = INPUT
        STA TBDATA
        LDA #$36     ; SELECT OUTPUT REGISTER A, CA2 LOW
        STA TACTRL
        LDA #$3E     ; SELECT OUTPUT REGISTER B, CB2 HIGH
        STA TBCTRL
        RTS
*
*
*
* DELAY LOOP
*
DLY     PSHS B        ; SAVE CONTENTS OF "B"
        LDB  #$20     ; GET LOOP DELAY VALUE
SUB1    DECB          ; SUBTRACT ONE FROM VALUE
        BNE  SUB1     ; LOOP UNTIL ZERO
        PULS B,PC     ; RESTORE CONTENTS OF "B"
* RTS  ;
*
***** "L" LOAD MIKBUG TAPE *****
*
LOAD    JSR  ACINIZ
        LDA  #$11     ; LOAD 'DC1' CASS. READ ON CODE
        LBSR OUTCH    ; OUTPUT IT TO TERMINAL PORT
        CLR  ECHO     ; TURN OFF ECHO FLAG
LOAD1   LBSR ECHON    ; INPUT 8 BIT BYTE WITH NO ECHO
LOAD2   CMPA #'S      ; IS IT AN "S", START CHARACTER ?
        BNE  LOAD1    ; IF NOT, DISCARD AND GET NEXT CHAR.
        LBSR ECHON
        CMPA #'9      ; IS IT A "9" , END OF FILE CHAR ?
        BEQ  LOAD20   ; IF SO, SKIP REMAINING AND EXIT LOAD
        CMPA #'1      ; IS IT A "1" , FILE LOAD CHAR ?
        BNE  LOAD2    ; IF NOT, LOOK FOR START CHAR.
        LBSR BYTE     ; INPUT BYTE COUNT
        PSHS A        ; PUSH COUNT ON STACK
        BVS  LODERR   ; (V) C-CODE SET, ILLEGAL HEX
        LBSR IN1ADR   ; INPUT LOAD ADDRESS
        BVS  LODERR   ; (V) C-CODE SET, ADDR NOT HEX
        PSHS X        ; PUSH ADDR ON STACK
        LDB  ,S+      ; LOAD MSB OF ADDR AS CHECKSUM BYTE
        ADDB ,S+      ; ADD LSB OF ADDR TO CHECKSUM
        ADDB ,S       ; ADD BYTE COUNT BYTE TO CHECKSUM
        DEC  ,S       ; $FC37 DECREMENT BYTE COUNT 2 TO BYPASS
        DEC  ,S       ; ADDRESS BYTES.
LOAD10  PSHS B        ; PUSH CHECKSUM ON STACK
        LBSR BYTE     ; INPUT DATA BYTE (2 HEX CHAR)
        PULS B        ; POP CHECKSUM FROM STACK
        BVS  LODERR   ; (V) SET, DATA BYTE NOT HEX
        PSHS A        ; PUSH DATA BYTE ON STACK
        ADDB ,S+      ; ADD DATA TO CHECKSUM, AUTO INC STACK
        DEC  ,S       ; DECREMENT BYTE COUNT 1
        BEQ  LOAD16   ; IF BYTE COUNT ZERO, TEST CHECKSUM
        STA  ,X+      ; SAVE DATA BYTE IN MEMORY
        BRA  LOAD10   ; GET NEXT DATA BYTE
LODERR  CLRB          ; ERROR CONDITION, ZERO CHECKSUM  ;
LOAD16  PULS A        ; ADJUST STACK (REMOVE BYTE COUNT)
        CMPB #$FF     ; CHECKSUM OK?
        BEQ  LOAD1    ; IF SO, LOAD NEXT LINE
        LDA  #'?      ; LOAD (?) ERROR INDICATOR
        LBSR OUTCH    ; OUTPUT IT TO TERMINAL
LOAD20  LBSR BYTE     ; SKIP BYTE COUNT
        LBSR BYTE     ; SKIP ADDRESS MSB
        LBSR BYTE     ; SKIP ADDRESS LSB
        LBSR BYTE     ; SKIP CHECKSUM
        LBSR ECHON    ; SKIP CR/LF
        LBSR ECHON    ; SKIP CR/LF
LOAD21  COM  ECHO     ; TURN ECHO ON
        LDA  #$13     ; $FC5F LOAD 'DC3' CASS. READ OFF CODE
        LBRA OUTCH    ; OUTPUT IT
*
***** "P" PUNCH MIKBUG TAPE *****
*
PUNCH   CLR  ,-S      ; CLEAR RESERVED BYTE ON STACK
        LBSR IN2ADR   ; GET BEGIN AND END ADDRESS
        PSHS X,Y      ; SAVE ADDRESSES ON STACK
        BVS  PUNEXT   ; (V) C-CODE SET, EXIT PUNCH
        CMPX 2,S      ; COMPARE BEGIN TO END ADDR
        BCS  PUNEXT   ; IF BEGIN GREATER THAN END, EXIT PUNCH
        LEAX 1,X      ; INCREMENT END ADDRESS
        STX  ,S       ; STORE END ADDR ON STACK
        JSR  ACINIZ
        LDA  #$12     ; LOAD 'DC2' PUNCH ON CODE
        LBSR OUTCH    ; OUTPUT IT TO TERMINAL
PUNCH2  LDD  ,S       ; LOAD END ADDR IN D-ACC
        SUBD 2,S      ; SUBTRACT BEGIN FROM END
        BEQ  PUNCH3   ; SAME, PUNCH 32 BYTES DEFAULT
        CMPD #$20     ; LESS THAN 32 BYTES?
        BLS  PUNCH4   ; PUNCH THAT MANY BYTES
PUNCH3  LDB  #$20     ; LOAD BYTE COUNT OF 32.
PUNCH4  STB  4,S      ; STORE ON STACK AS BYTE COUNT
        LDX  #MSG20   ; POINT TO MSG "S1"
        LBSR PSTRNG   ; PRINT MSG
        ADDB #3       ; ADD 3 BYTES TO BYTE COUNT
        TFR  B,A      ; GET BYTE COUNT IN A-ACC TO PUNCH
        LBSR OUT2H    ; OUTPUT BYTE COUNT
        LDX  2,S      ; LOAD BEGIN ADDRESS
        LBSR OUT4H    ; PUNCH ADDRESS
        ADDB 2,S      ; ADD ADDR MSB TO CHECKSUM
        ADDB 3,S      ; ADD ADDR LSB TO CHECKSUM
PUNCHL  ADDB ,X       ; ADD DATA BYTE TO CHECKSUM
        LDA  ,X+      ; LOAD DATA BYTE TO PUNCH
        LBSR OUT2H    ; OUTPUT DATA BYTE
        DEC  4,S      ; DECREMENT BYTE COUNT
        BNE  PUNCHL   ; NOT DONE, PUNCH NEXT BYTE
        COMB  1's     ; COMPLIMENT CHECKSUM BYTE
        TFR  B,A      ; GET IT IN A-ACC TO PUNCH
        LBSR OUT2H    ; OUTPUT CHECKSUM BYTE
        STX  2,S      ; SAVE X-REG IN STACK AS NEW PUNCH ADDR
        CMPX ,S       ; COMPARE IT TO END ADDR
        BNE  PUNCH2   ; $FCB5 PUNCH NOT DONE, CONT.
PUNEXT  LDA  #$14     ; LOAD 'DC4' PUNCH OFF CODE
        LBSR OUTCH    ; OUTPUT IT
        LEAS 5,S      ; READJUST STACK POINTER
        RTS  ;
*
* PRINT STRING PRECEEDED BY A CR & LF.
*
PSTRNG  BSR  PCRLF    ; PRINT CR/LF
        BRA  PDATA    ; PRINT STRING POINTED TO BY IX
*
* PCRLF
*
PCRLF   PSHS X        ; SAVE IX
        LDX  #MSG2+1  ; POINT TO MSG CR/LF + 3 NULS
        LBSR PDATA    ; PRINT MSG
        PULS X,PC     ; RESTORE IX & RETURN
*
* LONG BRANCHES TO COMMON ROUTINES
*
JOUT1S  LBRA OUT1S
JBYTE   LBRA BYTE
JIN1ADR LBRA IN1ADR
*
* ALTER "PC" PROGRAM COUNTER
*
ALTRPC  LBSR  PRTPC   ; $FCF5 PRINT MSG " PC = "
ALTPC1  BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JIN1ADR  ; GET NEW CONTENTS FOR "PC"
        BVS  ALTPCD   ; EXIT IF INVALID HEX
        STX  10,U     ; POKE IN NEW CONTENTS
ALTPCD  RTS           ;
*
* ALTER "U" USER STACK POINTER
*
ALTRU   BSR  PRTUS    ; $FCCA PRINT MSG " US = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JIN1ADR  ; GET NEW CONTENTS FOR "US"
        BVS  ALTUD    ; EXIT IF INVALID HEX
        STX  8,U      ; POKE IN NEW CONTENTS
ALTUD   RTS           ;
*
* ALTER "Y" INDEX REGISTER
*
ALTRY   BSR  PRTIY    ; PRINT MSG " IY = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JIN1ADR  ; GET NEW CONTENTS FOR "IY"
        BVS  ALTYD    ; EXIT IF INVALID HEX
        STX  6,U      ; $F8F0 POKE IN NEW CONTENTS
ALTYD   RTS           ;
*
* ALTER "X" INDEX REGISTER
*
ALTRX   BSR  PRTIX    ; $FCE0 PRINT MSG " IX = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JIN1ADR
        BVS  ALTXD
        STX  4,U
ALTXD   RTS ;
*
* ALTER "DP" DIRECT PAGE REGISTER
*
ALTRDP  BSR  PRTDP    ; $FCD5 PRINT MSG " DP = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JBYTE    ; INPUT BYTE (2 HEX CHAR)
        BVS  ALTDPD
        STA  3,U
ALTDPD  RTS ;
*
* ALTER "B" ACCUMULATOR
*
ALTRB   BSR  PRTB     ; $FD09 PRINT MSG " B = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JBYTE    ; INPUT BYTE (2 HEX CHAR)
        BVS  ALTBD
        STA  2,U
ALTBD   RTS           ; $F91C
*
* ALTER "A" ACCUMULATOR
*
ALTRA   BSR  PRTA     ; $FCFF RINT MSG " A = "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JBYTE    ; INPUT BYTE (2 HEX CHAR)
        BVS  ALTAD
        STA  1,U
ALTAD   RTS ;
*
* ALTER "CC" REGISTER
*
ALTRCC  BSR  PRTCC    ; $FD13 PRINT MSG " CC: "
        BSR  JOUT1S   ; OUTPUT SPACE
        BSR  JBYTE    ; INPUT BYTE (2 HEX CHAR)
        BVS  ALTCCD
        ORA  #$80     ; SETS "E" FLAG IN PRINT LIST
        STA  ,U
ALTCCD  RTS ;
*
* PDATA
*
PRINT   LBSR OUTCH
PDATA   LDA  ,X+      ; GET 1st CHAR. TO PRINT
        CMPA #4       ; IS IT EOT?
        BNE  PRINT    ; IF NOT EOT PRINT IT
        RTS  ;
*
* PRINT REGISTERS
*
PRTSP   LDX  #MSG10   ; POINT TO MSG "SP="
        BSR  PDATA    ; PRINT MSG
        TFR  U,X
JOUT4H  LBRA OUT4H
*
PRTUS   LDX  #MSG12   ; POINT TO MSG "US="
        BSR  PDATA    ; PRINT MSG
        LDX  8,U
        BRA  JOUT4H
*
PRTDP   LDX   #MSG15  ; POINT TO MSG "DP="
        BSR  PDATA    ; PRINT MSG
        LDA  3,U
JOUT2H  LBRA OUT2H    ; OUTPUT HEX BYTE AS ASCII
*
PRTIX   LDX  #MSG14   ; POINT TO MSG "IX="
        BSR  PDATA    ; PRINT MSG
        LDX  4,U      ; $FCE6
        BRA  JOUT4H
*
PRTIY   LDX  #MSG13   ; POINT TO MSG "IY="
        BSR  PDATA    ; PRINT MSG
        LDX  6,U
        BRA  JOUT4H
*
PRTPC   LDX  #MSG11   ; POINT TO MSG "PC="
        BSR  PDATA    ; PRINT MSG
        LDX  10,U
        BRA  JOUT4H
*
PRTA    LDX  #MSG16   ; POINT TO MSG "A="
        BSR  PDATA    ; PRINT MSG
        LDA  1,U
        BRA  JOUT2H   ; OUTPUT HEX BYTE AS ASCII
*
PRTB    LDX  #MSG17   ; POINT TO MSG "B="
        BSR  PDATA    ; PRINT MSG
        LDA  2,U
        BRA  JOUT2H   ; OUTPUT HEX BYTE AS ASCII
*
PRTCC   LDX  #MSG18   ; POINT TO MSG "CC:"
        BSR  PDATA    ; PRINT MSG
        LDA  ,U
        LDX  #MSG19   ; POINT TO MSG "EFHINZVC"
        LBRA BIASCI   ; OUTPUT IN BINARY/ASCII FORMAT
*
* "R" DISPLAY REGISTERS
*
REGSTR  LDX  #MSG5    ; POINT TO MSG " - "
        LBSR PSTRNG   ; PRINT MSG
        BSR  PRTSP    ; $FCBF
        BSR  PRTUS    ; $FCCA
        BSR  PRTDP    ; $FCD5
        BSR  PRTIX    ; $FCE0
        BSR  PRTIY    ; $FCEB
        LDX  #MSG5    ; POINT TO MSG " - "
        LBSR PSTRNG   ; PRINT MSG
        BSR  PRTPC    ; $FCF5
        BSR  PRTA     ; $FCFF
        BSR  PRTB     ; $FD09
        BRA  PRTCC    ; $FD13
*
* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT TWO VALID HEX ADDRESSES.
* THE FIRST ADDRESS INPUT IS RETURNED IN "IY".
* THE SECOND IS RETURNED IN "IX". THE "V" BIT
* IN THE C-CODE REG. IS SET IF AN INVALID HEX
* ADDRESS IS INPUT.
*
IN2ADR  BSR  IN1ADR   ; GET FIRST ADDRESS
        BVS  NOTHEX   ; EXIT IF NOT VALID HEX
        TFR  X,Y      ; SAVE FIRST ADDR. IN "IY"
        LDA  #'-
        LBSR OUTCH    ; PRINT " - "
*
* THE FOLLOWING ROUTINE LOOPS WAITING FOR THE
* OPERATOR TO INPUT ONE VALID HEX ADDRESS. THE
* ADDRESS IS RETURNED IN THE "X" REGISTER.
*
IN1ADR  BSR  BYTE     ; INPUT BYTE (2 HEX CHAR)
        BVS  NOTHEX   ; EXIT IF NOT VALID HEX
        TFR  D,X
        BSR  BYTE     ; INPUT BYTE (2 HEX CHAR)
        BVS  NOTHEX
        PSHS X
        STA  1,S
        PULS X,PC
*
***** INPUT BYTE (2 HEX CHAR.) *****
*
BYTE    BSR  INHEX    ; GET HEX LEFT
        BVS  NOTHEX   ; EXIT IF NOT VALID HEX
        ASLA          ;
        ASLA          ;
        ASLA          ; SHIFT INTO LEFT NIBBLE
        ASLA          ;
        TFR  A,B      ; PUT HEXL IN "B"
        BSR  INHEX    ; GET HEX RIGHT
        BVS  NOTHEX   ; EXIT IF NOT VALID HEX
        PSHS B        ; PUSH HEXL ON STACK
        ADDA ,S+      ; ADD HEXL TO HEXR AND ADJ. STK
        RTS           ; RETURN WITH HEX L&R IN "A"
*
*
INHEX   BSR  ECHON    ; INPUT ASCII CHAR.
        CMPA #'0      ; IS IT > OR = "0" ?
        BCS  NOTHEX   ; IF LESS IT AIN'T HEX
        CMPA #'9      ; IS IT < OR = "9" ?
        BHI  INHEXA   ; IF > MAYBE IT'S ALPHA
        SUBA #$30     ; ASCII ADJ. NUMERIC
        RTS           ;
*
*
INHEXA  CMPA #'A      ; IS IT > OR = "A"
        BCS  NOTHEX   ; IF LESS IT AIN'T HEX
        CMPA #'F      ; IS IT < OR = "F" ?
        BHI  INHEXL   ; IF > IT AIN'T HEX
        SUBA #'A-10   ; ($37) ASCII ADJ. ALPHA
        RTS           ;
*
INHEXL  CMPA #'a      ; IS IT > OR = "a"
        BCS  NOTHEX   ; IF LESS IT AIN'T HEX
        CMPA #'f      ; IS IT < "f"
        BHI  NOTHEX   ; IF > IT AIN'T HEX
        SUBA #'a-10   ; ($57) ADJUST TO LOWER CASE
        RTS           ;
*
*
NOTHEX  ORCC #2       ; SET (V) FLAG IN C-CODES REGISTER
        RTS           ;
*
*
OUT4H   PSHS X        ; PUSH X-REG. ON THE STACK
        PULS A        ; POP MS BYTE OF X-REG INTO A-ACC.
        BSR  OUTHL    ; OUTPUT HEX LEFT
        PULS A        ; POP LS BYTE OF X-REG INTO A-ACC.
OUTHL   EQU *
OUT2H   PSHS A        ; SAVE IT BACK ON STACK
        LSRA          ; CONVERT UPPER HEX NIBBLE TO ASCII
        LSRA          ;
        LSRA          ;
        LSRA          ;
        BSR  XASCII   ; PRINT HEX NIBBLE AS ASCII
OUTHR   PULS A        ; CONVERT LOWER HEX NIBBLE TO ASCII
        ANDA #$0F     ; STRIP LEFT NIBBLE
XASCII  ADDA #$30     ; ASCII ADJ
        CMPA #$39     ; IS IT < OR = "9" ?
        BLE  OUTC     ; IF LESS, OUTPUT IT
        ADDA #7       ; IF > MAKE ASCII LETTER
OUTC    BRA  OUTCH    ; OUTPUT CHAR
*
* BINARY / ASCII --- THIS ROUTINE
* OUTPUTS A BYTE IN ENHANCED
* BINARY FORMAT. THE ENHANCEMENT
* IS DONE BY SUBSTITUTING ASCII
* LETTERS FOR THE ONES IN THE BYTE.
* THE ASCII ENHANCEMENT LETTERS
* ARE OBTAINED FROM THE STRING
* POINTED TO BY THE INDEX REG. "X".
*
BIASCI  PSHS A        ; SAVE "A" ON STACK
        LDB  #8       ; PRESET LOOP# TO BITS PER BYTE
OUTBA   LDA  ,X+      ; GET LETTER FROM STRING
        ASL  ,S       ; TEST BYTE FOR "1" IN B7
        BCS  PRTBA    ; IF ONE PRINT LETTER
        LDA  #'-      ; IF ZERO PRINT "-"
PRTBA   BSR  OUTCH    ; PRINT IT
        BSR  OUT1S    ; PRINT SPACE
        DECB          ; SUB 1 FROM #BITS YET TO PRINT
        BNE  OUTBA
        PULS A,PC
*
*
*
ECHON   TST  ECHO     ; IS ECHO REQUIRED ?
        BEQ  INCH     ; ECHO NOT REQ. IF CLEAR
*
* INCHE
*
* GETS CHARACTER FROM TERMINAL AND
* ECHOS SAME. THE CHARACTER IS RETURNED
* IN THE "A" ACCUMULATOR WITH THE PARITY
* BIT MASKED OFF. ALL OTHER REGISTERS
* ARE PRESERVED.
*
INCHE   BSR  INCH     ; GET CHAR FROM TERMINAL
        ANDA #$7F     ; STRIP PARITY FROM CHAR.
        BRA  OUTCH    ; ECHO CHAR TO TERMINAL
*
* INCH
*
* GET CHARACTER FROM TERMINAL. RETURN
* CHARACTER IN "A" ACCUMULATOR AND PRESERVE
* ALL OTHER REGISTERS. THE INPUT CHARACTER
* IS 8 BITS AND IS NOT ECHOED.
*
*
INCH    PSHS X        ; SAVE IX
GETSTA  LDX  CPORT    ; POINT TO TERMINAL PORT
        LDA  ,X       ; FETCH PORT STATUS
        BITA #1       ; TEST READY BIT, RDRF ?
        BNE  GETST1
        LDX  #PS2KBD
        LDA  ,X
        BITA #1
        BEQ  GETSTA   ; IF NOT RDY, THEN TRY AGAIN
GETST1  EQU  *
        LDA  1,X      ; FETCH CHAR
        PULS X,PC     ; RESTORE IX
*
* INCHEK
*
* CHECK FOR A CHARACTER AVAILABLE FROM
* THE TERMINAL. THE SERIAL PORT IS CHECKED
* FOR READ READY. ALL REGISTERS ARE
* PRESERVED, AND THE "Z" BIT WILL BE
* CLEAR IF A CHARACTER CAN BE READ.
*
*
INCHEK  PSHS A        ; SAVE A ACCUM
        LDA  [CPORT]  ; FETCH PORT STATUS
        BITA #1       ; TEST READY BIT, RDRF ?
        BNE  INCHEK1
        LDA  PS2KBD
        BITA #1       ; TEST READY BIT< RDRF ?
INCHEK1 PULS A,PC     ; RESTORE A ACCUM.
*
OUT2S   BSR  OUT1S    ; OUTPUT 2 SPACES
OUT1S   LDA  #$20     ; OUTPUT 1 SPACE
*
*
* OUTCH
*
* OUTPUT CHARACTER TO TERMINAL.
* THE CHAR. TO BE OUTPUT IS
* PASSED IN THE A REGISTER.
* ALL REGISTERS ARE PRESERVED.
*
OUTCH   BSR   VOUTCH
AOUTCH  PSHS A,X      ; SAVE A ACCUM AND IX
        LDX  CPORT    ; GET ADDR. OF TERMINAL
FETSTA  LDA  ,X       ; FETCH PORT STATUS
        BITA #2       ; TEST TDRE, OK TO XMIT ?
        BEQ  FETSTA   ; IF NOT LOOP UNTIL RDY
        BITA #8       ; CLEAR TO SEND ?
        BNE  FETSTA   ; NO, LOOP UNTIL CLEAR
        PULS A        ; GET CHAR. FOR XMIT
        STA  1,X      ; XMIT CHAR.
        PULS X,PC     ; RESTORE IX
*
* IO INITIALIZATION
*
IOINIZ  EQU  *
        BSR  VINIZ
ACINIZ  LDX  CPORT    ; POINT TO CONTROL PORT ADDRESS
        LDA  #3       ; RESET ACIA PORT CODE
        STA  ,X       ; STORE IN CONTROL REGISTER
        LDA  #$51     ; SET 8 DATA, 2 STOP AN 0 PARITY RTS* HIGH
        STA  ,X       ; STORE IN CONTROL REGISTER
        TST  1,X      ; ANYTHING IN DATA REGISTER?
        LDA  #$FF     ; TURN ON ECHO FLAG
        STA  ECHO
        RTS
*
*
***************************************************
*      VDU8 ADM3A REGISTER-MAPPED EMULATOR        *
*                                                 *
*      80 x 25 Characters
*
***************************************************
*
***************************************************
*               INITIALIZE EMULATOR               *
***************************************************
*
VINIZ   LDX  #VDU
        LDD  #0
        STD  COLADX   ; AND ROWADX
        STA  VDUCOL,X
        STB  VDUROW,X
        STB  VDUOFF,X
        STD  NEWROW   ; AND ESCFLG
        LDB  #$02
        STB  VDUATT,X
        CLR  ESCFLG
        LDA  #$1B     ; SEND ESCAPE
        BSR  VOUTCH
        LDA  #'Y      ; CLEAR TO END OF SCREEN
*
** VIDEO OUTPUT ROUTINE
*
VOUTCH  PSHS A,B,X    ; SAVE REGISTERS
        LDX  #VDU     ; POINT TO VDU REGISTERS
*
** CHECK FOR ESCAPE SEQUENCE
*
        TST  ESCFLG   ; ESCAPE ACTIVE?
        BEQ  SOROU1   ; BRANCH IF NOT
        BSR  ESCAPE   ; ELSE DO ESCAPE
        BRA  RETURN   ; AND RETURN
*
** CHECK FOR CONTROL CHARACTERS
*
SOROU1  CMPA #$20     ; CONTROL CODES?
        BHS  SOROU2
        BSR  CONTRL   ; BRANCH IF SO
        BRA  RETURN
*
** OUTPUT TEXT CHARACTER
*
SOROU2  STA  VDUCHR,X ; DISPLAY CHARACTER
        LBSR NEWCOL   ; UPDATE COLUMN
*
** DISPLAY CURSOR AND RETURN
*
RETURN  PULS A,B,X,PC ; RESTORE REGISTERS AND RETURN
*
***************************************************
*              CONTROL CODE HANDLERS              *
***************************************************
*
CONTRL  CMPA #$08     ; CTRL H - BACKSPACE ?
        BEQ  BACKSP
        CMPA #$1B     ; ESCAPE SEQUENCE?
        BEQ  SETESC
        CMPA #$1A     ; CTRL Z - Clear Screen
        LBEQ CLRSCR
        CMPA #$16     ; CTRL ^ - Home
        BEQ  HOME
        CMPA #$0D     ; CTRL M - RETURN?
        LBEQ CRETN
        CMPA #$0C     ; CTRL L - CHAR RIGHT
        BEQ  CHRIGHT
        CMPA #$0B     ; CTRL K - MOVE UP ONE LINE
        BEQ  LINEUP
        CMPA #$0A     ; CTRL J - LINE FEED
        BNE  RETESC   ; NONE OF THESE, RETURN
*
***************************************** LINE FEED
*
LINEFD  LDD  COLADX   ; GET CURRENT COLUMN AND ROW
        INCB          ; BUMP ROW
        CMPB #NUMLIN  ; SCROLL TIME?
        BNE  NEWCUR   ; POSITION CURSOR IF NOT
        LBRA SCROLL   ; ELSE SCROLL IT
*
***************************************** LINE FEED
*
LINEUP  LDD  COLADX   ; GET CURRENT COLUMN AND ROW
        TSTB          ; AT TOP OF SCREEN ?
        BEQ  RETESC   ; Yes, Ignore
        DECB          ; No, Decrement ROW
        BRA  NEWCUR   ; POSITION CURSOR
*
*********************************** BACK SPACE
*
BACKSP  LDA  COLADX
        BEQ  RETESC   ; RETURN
        DECA
        BRA  POSCOL   ; POSITION CURSOR
*
*********************************** CURSOR RIGHT
*
CHRIGHT LDA  COLADX
        INCA
        CMPA #LINLEN
        BEQ  RETESC
        BRA  POSCOL
*
*********************************** CURSOR RIGHT
*
HOME    LDD  #0       ; HOME - POSITION TOP OF SCREEN
        BRA  NEWCUR
*
***************************************************
*                 ESCAPE HANDLERS                 *
***************************************************
*
ESCAPE  LDB  ESCFLG   ; GET FLAG
        CMPB #'=      ; SETTING CURSOR?
        BEQ  ESCCUR   ; BRANCH IF SO
        CMPA #'Y      ; CLEAR TO END OF SCREEN?
        BEQ  ESCCLS
        CMPA #'T      ; CLEAR TO END OF LINE?
        BEQ  ESCCLL
        CMPA #'=      ; STARTING CURSOR SET?
        BNE  CLRESC   ; BRANCH IF NOT
*
***************************** START ESCAPE SEQUENCE
*
SETESC  STA  ESCFLG   ; ELSE START CURSORING
        RTS           ; AND RETURN
*
CLRESC  CLR  ESCFLG   ; NO OTHERS SUPPORTED
RETESC  RTS           ; SO RETURN
*
********************************* SET SCREEN CURSOR
*
ESCCUR  TST  NEWROW   ; ROW SET?
        BNE  ESCCU1   ; BRANCH IF SO
        STA  NEWROW   ; ELSE SET NEW ROW
        RTS           ; AND RETURN
*
ESCCU1  CLR  ESCFLG
        SUBA #$20     ; ADJUST COLUMN ADDRESS
        CMPA #LINLEN-1 ;CHECK FOR ACCEPTABLE COLUM
        BHI  RETESC   ; NOT OK, DO NOTHING
*
ESCCU2  LDB  NEWROW
        CLR  NEWROW
        SUBB #$20     ; ADJUST TO ROW ADDRESS
        CMPB #NUMLIN-1 ; CHECK FOR ACCEPTABLE ROW
        BHI  RETESC   ; ELSE RETURN DOING NOTHING
        BRA  NEWCUR   ; GO SET NEW CURSOR IF SO
*
****************** CLEAR FROM CURSOR TO END OF LINE
*
CLRSCR  LDD  #0       ; CLEAR FROM TOP OF SCREEN
        BSR  NEWCUR
ESCCLL  LDA  COLADX
        LDB  #$20     ; AND CLEAR CHAR
ESCCL1  STB  VDUCHR,X ; DISPLAY TEXT
        INCA
	STA  VDUCOL,X
        CMPA #LINLEN  ; UNTIL END OF LINE
        BNE  ESCCL1
        CLR  ESCFLG
        RTS
*
*********************************** CARRIAGE RETURN
*
CRETN   CLRA          ; SET COLUMN ZERO
POSCOL  LDB  ROWADX   ; GET CURRENT ROW
*
*********** GENERATE NEW CURSOR POSITION AND RETURN
*
NEWCUR  STD  COLADX   ; SAVE NEW ROW AND COLUMN
	STA  VDUCOL,X ; SET NEW COLUMN
        STB  VDUROW,X ; SET NEW ROW
        RTS           ; AND RETURN
*
********************* UPDATE CURRENT COLUMN AND ROW
*
NEWCOL  LDD  COLADX   ; GET ROW AND COLUMN
        INCA          ; BUMP COLUMN
        CMPA #LINLEN  ; ROLL?
        BNE  NEWCUR   ; BRANCH IF NOT
        CLRA          ; ELSE RESET TO ZERO
        INCB          ; AND BUMP ROW
        CMPB #NUMLIN
        BNE  NEWCUR
        DECB          ; BOTTOM ROW
        BSR  NEWCUR
*
********************************* SCROLL THE SCREEN
*
SCROLL  LDB  VDUOFF,X
        INCB
        CMPB #NUMLIN
        BLO  SCROL1
        CLRB
SCROL1  STB  VDUOFF,X
*
**************** CLEAR FROM CURSOR TO END OF SCREEN
*
ESCCLS  LDB  COLADX   ; GET CURSOR
        LDA  #$20     ; GET A SPACE
ESCCLS1	STB  COLADX
        STB  VDUCOL,X
        STA  VDUCHR,X
        INCB
        CMPB #LINLEN
        BNE  ESCCLS1
*
        LDB  ROWADX
        INCB
        CMPB #NUMLIN
        BEQ  ESCCLS2
        STB  ROWADX
        STB  VDUROW,X
        CLRB
        BRA  ESCCLS1
*
ESCCLS2 CLRB
        STB  COLADX
        STB  VDUCOL,X
        STB  ESCFLG
        RTS
*
*************************************
*
* MONITOR KEYBOARD COMMAND JUMP TABLE
*
*************************************
*
JMPTAB  EQU *
        FCB 1 " ^A "
        FDB ALTRA
        FCB 2 " ^B "
        FDB ALTRB
        FCB 3 " ^C "
        FDB ALTRCC
        FCB 4 " ^D "
        FDB ALTRDP
        FCB $10 " ^P "
        FDB ALTRPC
        FCB $15 " ^U "
        FDB ALTRU
        FCB $18 " ^X "
        FDB ALTRX
        FCB $19 " ^Y "
        FDB ALTRY
*
        FCC 'B'
        FDB BRKPNT
        FCC 'E'
        FDB MEMDUMP
        FCC 'G'
        FDB GO
        FCC 'L'
        FDB LOAD
        FCC 'P'
        FDB PUNCH
        FCC 'M'
        FDB MEMCHG
        FCC 'R'
        FDB REGSTR
        FCC 'S'
        FDB DISSTK
        FCC 'X'
        FDB XBKPNT
        FCC "T"
        FDB TRACE
*
TABEND  EQU *
*
* ** 6809 VECTOR ADDRESSES **
*
* FOLLOWING ARE THE ADDRESSES OF THE VECTOR ROUTINES
* FOR THE 6809 PROCESSOR. DURING INITIALIZATION THEY
* ARE RELOCATED TO RAM FROM $DFC0 TO $DFCF. THEY ARE
* RELOCATED TO RAM SO THAT THE USER MAY REVECTOR TO
* HIS OWN ROUTINES IF HE SO DESIRES.
*
*
RAMVEC  FDB SWIE       ; USER-V
        FDB RTI        ; SWI3-V
        FDB RTI        ; SWI2-V
        FDB RTI        ; FIRQ-V
        FDB RTI        ; IRQ-V
        FDB SWIE       ; SWI-V
        FDB $FFFF      ; SVC-VO
        FDB $FFFF      ; SVC-VL
*
* PRINTABLE MESSAGE STRINGS
*
MSG1    FCB  $D,$A,$0,$0,$0 * 0, CR/LF, 0
        FCC  'SYS09BUG FOR '
        FCC  'MDSYNTH'
        FCC ' - '
        FCB 4
MSG2    FCB 'K,$0D,$0A,$00,$00,$00,$04 ; K,<CR>,<LF>,3 NULS,<EOT>
MSG3    FCC '>'
        FCB 4
MSG4    FCC 'WHAT?'
        FCB 4
MSG5    FCC ' - '
        FCB 4'
MSG10   FCC '  SP='
        FCB 4
MSG11   FCC '  PC='
        FCB 4
MSG12   FCC '  US='
        FCB 4
MSG13   FCC '  IY='
        FCB 4
MSG14   FCC '  IX='
        FCB 4
MSG15   FCC '  DP='
        FCB 4
MSG16   FCC '  A='
        FCB 4
MSG17   FCC '  B='
        FCB 4
MSG18   FCC '  CC: '
        FCB 4
MSG19   FCC 'EFHINZVC'
MSG20   FCC 'S1'
        FCB 4
LRA     RTS

****************************************************
* START
*
START   LDS  #STACK    ; INITIALIZE STACK POINTER
        CLRB
*
        COMB           ; SET "B" NON-ZERO
        STB  ECHO      ; TURN ON ECHO FLAG
        LBRA MONITOR   ; INITIALIZATION IS COMPLETE
*
** INTERRUPT JUMP VECTORS
*
V1      JMP  [STACK]
V2      JMP  [SWI2]
V3      JMP  [FIRQ]
V4      JMP  [IRQ]
V5      JMP  [SWI]
*
* SWI3 ENTRY POINT
*
SWI3E   TFR  S,U
        LDX  10,U      *$FFC8
        LDB  ,X+
        STX  10,U
        CLRA
        ASLB
        ROLA
        LDX  SVCVO
        CMPX #$FFFF
        BEQ  SWI3Z
        LEAX D,X
        CMPX SVCVL
        BHI  SWI3Z
        PSHS X
        LDD  ,U
        LDX  4,U
        JMP  [,S++]
SWI3Z   PULU A,B,X,CC,DP
        LDU  2,U
        JMP  [SWI3]
*
* 6809 VECTORS
*
        ORG $FFF0
        FDB V1    USER-V
        FDB SWI3E SWI3-V
        FDB V2    SWI2-V
        FDB V3    FIRQ-V
        FDB V4    IRQ-V
        FDB V5    SWI-V
        FDB V1    NMI-V
        FDB START RESTART-V
        END START
